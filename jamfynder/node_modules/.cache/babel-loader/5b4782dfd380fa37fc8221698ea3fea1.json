{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport getStyles from './styles';\nimport { getBaseProps, getCoordinates, getNormalizedValue, getPosition, isUndefined, removeProperties } from './utils';\nvar RangeSlider = /** @class */function (_super) {\n  __extends(RangeSlider, _super);\n  function RangeSlider(props) {\n    var _this = _super.call(this, props) || this;\n    _this.lastCoordinates = {\n      x: 0,\n      y: 0\n    };\n    _this.mounted = false;\n    _this.offset = {\n      x: 0,\n      y: 0\n    };\n    _this.start = {\n      x: 0,\n      y: 0\n    };\n    _this.getDragPosition = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      return {\n        x: x + _this.start.x - _this.offset.x,\n        y: _this.offset.y + _this.start.y - y\n      };\n    };\n    _this.updateOptions = function (_a) {\n      var _b, _c, _d, _e, _f, _g, _h, _j;\n      var x = _a.x,\n        y = _a.y;\n      var _k = _this,\n        rail = _k.rail,\n        track = _k.track;\n      _this.start = {\n        x: (_c = (_b = rail.current) === null || _b === void 0 ? void 0 : _b.offsetLeft) !== null && _c !== void 0 ? _c : 0,\n        y: ((_e = (_d = track.current) === null || _d === void 0 ? void 0 : _d.offsetHeight) !== null && _e !== void 0 ? _e : 0) - ((_g = (_f = rail.current) === null || _f === void 0 ? void 0 : _f.offsetTop) !== null && _g !== void 0 ? _g : 0) - ((_j = (_h = rail.current) === null || _h === void 0 ? void 0 : _h.offsetHeight) !== null && _j !== void 0 ? _j : 0)\n      };\n      _this.lastCoordinates = {\n        x: x,\n        y: y\n      };\n      _this.offset = {\n        x: x,\n        y: y\n      };\n    };\n    _this.updatePosition = function (position) {\n      _this.setState(getPosition(position, _this.props, _this.slider.current));\n    };\n    _this.handleBlur = function () {\n      document.removeEventListener('keydown', _this.handleKeydown);\n    };\n    _this.handleClickTrack = function (event) {\n      var onAfterEnd = _this.props.onAfterEnd;\n      var isDragging = _this.state.isDragging;\n      if (!isDragging) {\n        var element = event.currentTarget;\n        var _a = getCoordinates(event, _this.lastCoordinates),\n          x = _a.x,\n          y = _a.y;\n        var _b = element.getBoundingClientRect(),\n          bottom = _b.bottom,\n          left = _b.left;\n        var nextPosition = {\n          x: x - left,\n          y: bottom - y\n        };\n        _this.lastCoordinates = {\n          x: x,\n          y: y\n        };\n        _this.updatePosition(nextPosition);\n        if (onAfterEnd) {\n          onAfterEnd(getPosition(nextPosition, _this.props, _this.slider.current), _this.props);\n        }\n      } else if (_this.mounted) {\n        _this.setState({\n          isDragging: false\n        });\n      }\n    };\n    _this.handleDrag = function (event) {\n      event.preventDefault();\n      var coordinates = getCoordinates(event, _this.lastCoordinates);\n      _this.updatePosition(_this.getDragPosition(coordinates));\n      _this.lastCoordinates = coordinates;\n    };\n    _this.handleDragEnd = function (event) {\n      event.preventDefault();\n      var _a = _this.props,\n        onAfterEnd = _a.onAfterEnd,\n        onDragEnd = _a.onDragEnd;\n      var position = getPosition(_this.getDragPosition(getCoordinates(event, _this.lastCoordinates)), _this.props, _this.slider.current);\n      document.removeEventListener('mousemove', _this.handleDrag);\n      document.removeEventListener('mouseup', _this.handleDragEnd);\n      document.removeEventListener('touchmove', _this.handleDrag);\n      document.removeEventListener('touchend', _this.handleDragEnd);\n      document.removeEventListener('touchcancel', _this.handleDragEnd);\n      /* istanbul ignore else */\n      if (onDragEnd) {\n        onDragEnd(position, _this.props);\n      }\n      /* istanbul ignore else */\n      if (onAfterEnd) {\n        onAfterEnd(position, _this.props);\n      }\n    };\n    _this.handleFocus = function () {\n      document.addEventListener('keydown', _this.handleKeydown, {\n        passive: false\n      });\n    };\n    _this.handleKeydown = function (event) {\n      var _a = _this.state,\n        innerX = _a.x,\n        innerY = _a.y;\n      var _b = _this.props,\n        x = _b.x,\n        y = _b.y;\n      var _c = getBaseProps(_this.props),\n        axis = _c.axis,\n        xMax = _c.xMax,\n        xMin = _c.xMin,\n        xStep = _c.xStep,\n        yMax = _c.yMax,\n        yMin = _c.yMin,\n        yStep = _c.yStep;\n      var codes = {\n        down: 'ArrowDown',\n        left: 'ArrowLeft',\n        up: 'ArrowUp',\n        right: 'ArrowRight'\n      };\n      /* istanbul ignore else */\n      if (Object.values(codes).includes(event.code)) {\n        event.preventDefault();\n        var position = {\n          x: isUndefined(x) ? innerX : getNormalizedValue('x', _this.props),\n          y: isUndefined(y) ? innerY : getNormalizedValue('y', _this.props)\n        };\n        var xMinus = position.x - xStep <= xMin ? xMin : position.x - xStep;\n        var xPlus = position.x + xStep >= xMax ? xMax : position.x + xStep;\n        var yMinus = position.y - yStep <= yMin ? yMin : position.y - yStep;\n        var yPlus = position.y + yStep >= yMax ? yMax : position.y + yStep;\n        switch (event.code) {\n          case codes.up:\n            {\n              if (axis === 'x') {\n                position.x = xPlus;\n              } else {\n                position.y = yPlus;\n              }\n              break;\n            }\n          case codes.down:\n            {\n              if (axis === 'x') {\n                position.x = xMinus;\n              } else {\n                position.y = yMinus;\n              }\n              break;\n            }\n          case codes.left:\n            {\n              if (axis === 'y') {\n                position.y = yMinus;\n              } else {\n                position.x = xMinus;\n              }\n              break;\n            }\n          case codes.right:\n          default:\n            {\n              if (axis === 'y') {\n                position.y = yPlus;\n              } else {\n                position.x = xPlus;\n              }\n              break;\n            }\n        }\n        _this.setState(position);\n      }\n    };\n    _this.handleMouseDown = function (event) {\n      event.preventDefault();\n      _this.updateOptions(getCoordinates(event, _this.lastCoordinates));\n      _this.setState({\n        isDragging: true\n      });\n      document.addEventListener('mousemove', _this.handleDrag);\n      document.addEventListener('mouseup', _this.handleDragEnd);\n    };\n    _this.handleTouchStart = function (event) {\n      event.preventDefault();\n      _this.updateOptions(getCoordinates(event, _this.lastCoordinates));\n      document.addEventListener('touchmove', _this.handleDrag, {\n        passive: false\n      });\n      document.addEventListener('touchend', _this.handleDragEnd, {\n        passive: false\n      });\n      document.addEventListener('touchcancel', _this.handleDragEnd, {\n        passive: false\n      });\n    };\n    _this.slider = React.createRef();\n    _this.rail = React.createRef();\n    _this.track = React.createRef();\n    _this.state = {\n      isDragging: false,\n      x: getNormalizedValue('x', props),\n      y: getNormalizedValue('y', props)\n    };\n    return _this;\n  }\n  RangeSlider.prototype.componentDidMount = function () {\n    this.mounted = true;\n  };\n  RangeSlider.prototype.componentDidUpdate = function (_, previousState) {\n    var _a = this.state,\n      x = _a.x,\n      y = _a.y;\n    var onChange = this.props.onChange;\n    var previousX = previousState.x,\n      previousY = previousState.y;\n    /* istanbul ignore else */\n    if (onChange && (x !== previousX || y !== previousY)) {\n      onChange({\n        x: x,\n        y: y\n      }, this.props);\n    }\n  };\n  RangeSlider.prototype.componentWillUnmount = function () {\n    this.mounted = false;\n  };\n  Object.defineProperty(RangeSlider.prototype, \"position\", {\n    get: function get() {\n      var _a = getBaseProps(this.props),\n        axis = _a.axis,\n        xMax = _a.xMax,\n        xMin = _a.xMin,\n        yMax = _a.yMax,\n        yMin = _a.yMin;\n      var bottom = (this.y - yMin) / (yMax - yMin) * 100;\n      var left = (this.x - xMin) / (xMax - xMin) * 100;\n      if (bottom > 100) {\n        bottom = 100;\n      }\n      if (bottom < 0) {\n        bottom = 0;\n      }\n      // bottom shouldn't be set with X axis\n      /* istanbul ignore else */\n      if (axis === 'x') {\n        bottom = 0;\n      }\n      if (left > 100) {\n        left = 100;\n      }\n      if (left < 0) {\n        left = 0;\n      }\n      // left shouldn't be set with Y axis\n      /* istanbul ignore else */\n      if (axis === 'y') {\n        left = 0;\n      }\n      return {\n        x: left,\n        y: bottom\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RangeSlider.prototype, \"styles\", {\n    get: function get() {\n      var styles = this.props.styles;\n      return getStyles(styles);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RangeSlider.prototype, \"x\", {\n    get: function get() {\n      var innerX = this.state.x;\n      var x = this.props.x;\n      return isUndefined(x) ? innerX : x;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RangeSlider.prototype, \"y\", {\n    get: function get() {\n      var innerY = this.state.y;\n      var y = this.props.y;\n      return isUndefined(y) ? innerY : y;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  RangeSlider.prototype.render = function () {\n    var _a = this.props,\n      axis = _a.axis,\n      className = _a.className,\n      xMax = _a.xMax,\n      xMin = _a.xMin,\n      yMax = _a.yMax,\n      yMin = _a.yMin;\n    var rest = removeProperties(this.props, 'axis', 'className', 'onAfterEnd', 'onChange', 'onDragEnd', 'styles', 'x', 'xMin', 'xMax', 'xStep', 'y', 'yMin', 'yMax', 'yStep');\n    var _b = this.position,\n      xPos = _b.x,\n      yPos = _b.y;\n    var position = {\n      left: \"\".concat(xPos, \"%\"),\n      bottom: \"\".concat(yPos, \"%\")\n    };\n    var size = {};\n    var orientation;\n    var range;\n    var slider;\n    var thumb;\n    var track;\n    var valuemax = xMax;\n    var valuemin = xMin;\n    var valuenow = this.x;\n    /* istanbul ignore else */\n    if (axis === 'x') {\n      size.width = \"\".concat(xPos, \"%\");\n      slider = this.styles.sliderX;\n      orientation = 'horizontal';\n      range = this.styles.rangeX;\n      track = this.styles.trackX;\n      thumb = this.styles.thumbX;\n    }\n    /* istanbul ignore else */\n    if (axis === 'y') {\n      size.height = \"\".concat(yPos, \"%\");\n      slider = this.styles.sliderY;\n      range = this.styles.rangeY;\n      track = this.styles.trackY;\n      thumb = this.styles.thumbY;\n      orientation = 'vertical';\n      valuemax = yMax;\n      valuemin = yMin;\n      valuenow = this.y;\n    }\n    /* istanbul ignore else */\n    if (axis === 'xy') {\n      size.height = \"\".concat(yPos, \"%\");\n      size.width = \"\".concat(xPos, \"%\");\n      slider = this.styles.sliderXY;\n      range = this.styles.rangeXY;\n      track = this.styles.trackXY;\n      thumb = this.styles.thumbXY;\n    }\n    return React.createElement(\"div\", __assign({\n      ref: this.slider,\n      className: className,\n      style: slider\n    }, rest), React.createElement(\"div\", {\n      ref: this.track,\n      className: className && \"\".concat(className, \"__track\"),\n      onClick: this.handleClickTrack,\n      role: \"presentation\",\n      // @ts-ignore We can't use React's events because the listeners\n      style: track\n    }, React.createElement(\"div\", {\n      className: className && \"\".concat(className, \"__range\"),\n      style: __assign(__assign({}, size), range)\n    }), React.createElement(\"div\", {\n      ref: this.rail,\n      onMouseDown: this.handleMouseDown,\n      onTouchStart: this.handleTouchStart,\n      // @ts-ignore We can't use React's events because the listeners\n      role: \"presentation\",\n      // @ts-ignore We can't use React's events because the listeners\n      style: __assign(__assign({}, this.styles.rail), position)\n    }, React.createElement(\"span\", {\n      \"aria-label\": \"slider handle\",\n      \"aria-orientation\": orientation,\n      \"aria-valuemax\": valuemax,\n      \"aria-valuemin\": valuemin,\n      \"aria-valuenow\": valuenow,\n      className: className && \"\".concat(className, \"__thumb\"),\n      onBlur: this.handleBlur,\n      onFocus: this.handleFocus,\n      role: \"slider\",\n      style: thumb,\n      tabIndex: 0\n    }))));\n  };\n  RangeSlider.defaultProps = getBaseProps();\n  return RangeSlider;\n}(React.Component);\nexport * from './types';\nexport default RangeSlider;","map":null,"metadata":{},"sourceType":"module"}