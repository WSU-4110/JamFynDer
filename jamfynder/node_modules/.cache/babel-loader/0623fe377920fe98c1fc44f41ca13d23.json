{"ast":null,"code":"'use strict';\n\nvar AuthenticationRequest = require('./authentication-request'),\n  WebApiRequest = require('./webapi-request'),\n  HttpManager = require('./http-manager');\nfunction SpotifyWebApi(credentials) {\n  this._credentials = credentials || {};\n}\nSpotifyWebApi.prototype = {\n  setCredentials: function setCredentials(credentials) {\n    for (var key in credentials) {\n      if (credentials.hasOwnProperty(key)) {\n        this._credentials[key] = credentials[key];\n      }\n    }\n  },\n  getCredentials: function getCredentials() {\n    return this._credentials;\n  },\n  resetCredentials: function resetCredentials() {\n    this._credentials = null;\n  },\n  setClientId: function setClientId(clientId) {\n    this._setCredential('clientId', clientId);\n  },\n  setClientSecret: function setClientSecret(clientSecret) {\n    this._setCredential('clientSecret', clientSecret);\n  },\n  setAccessToken: function setAccessToken(accessToken) {\n    this._setCredential('accessToken', accessToken);\n  },\n  setRefreshToken: function setRefreshToken(refreshToken) {\n    this._setCredential('refreshToken', refreshToken);\n  },\n  setRedirectURI: function setRedirectURI(redirectUri) {\n    this._setCredential('redirectUri', redirectUri);\n  },\n  getRedirectURI: function getRedirectURI() {\n    return this._getCredential('redirectUri');\n  },\n  getClientId: function getClientId() {\n    return this._getCredential('clientId');\n  },\n  getClientSecret: function getClientSecret() {\n    return this._getCredential('clientSecret');\n  },\n  getAccessToken: function getAccessToken() {\n    return this._getCredential('accessToken');\n  },\n  getRefreshToken: function getRefreshToken() {\n    return this._getCredential('refreshToken');\n  },\n  resetClientId: function resetClientId() {\n    this._resetCredential('clientId');\n  },\n  resetClientSecret: function resetClientSecret() {\n    this._resetCredential('clientSecret');\n  },\n  resetAccessToken: function resetAccessToken() {\n    this._resetCredential('accessToken');\n  },\n  resetRefreshToken: function resetRefreshToken() {\n    this._resetCredential('refreshToken');\n  },\n  resetRedirectURI: function resetRedirectURI() {\n    this._resetCredential('redirectUri');\n  },\n  _setCredential: function _setCredential(credentialKey, value) {\n    this._credentials = this._credentials || {};\n    this._credentials[credentialKey] = value;\n  },\n  _getCredential: function _getCredential(credentialKey) {\n    if (!this._credentials) {\n      return;\n    } else {\n      return this._credentials[credentialKey];\n    }\n  },\n  _resetCredential: function _resetCredential(credentialKey) {\n    if (!this._credentials) {\n      return;\n    } else {\n      this._credentials[credentialKey] = null;\n    }\n  },\n  /**\n   * Look up a track.\n   * @param {string} trackId The track's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getTrack('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the track. Not returned if a callback is given.\n   */\n  getTrack: function getTrack(trackId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/tracks/' + trackId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Look up several tracks.\n   * @param {string[]} trackIds The IDs of the artists.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtists(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artists. Not returned if a callback is given.\n   */\n  getTracks: function getTracks(trackIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/tracks').withQueryParameters({\n      ids: trackIds.join(',')\n    }, options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Look up an album.\n   * @param {string} albumId The album's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbum('0sNOF9WDwhWunNAHPD3Baj').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the album. Not returned if a callback is given.\n   */\n  getAlbum: function getAlbum(albumId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/albums/' + albumId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Look up several albums.\n   * @param {string[]} albumIds The IDs of the albums.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbums(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the albums. Not returned if a callback is given.\n   */\n  getAlbums: function getAlbums(albumIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/albums').withQueryParameters({\n      ids: albumIds.join(',')\n    }, options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Look up an artist.\n   * @param {string} artistId The artist's ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example api.getArtist('1u7kkVrr14iBvrpYnZILJR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artist. Not returned if a callback is given.\n   */\n  getArtist: function getArtist(artistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists/' + artistId).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Look up several artists.\n   * @param {string[]} artistIds The IDs of the artists.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtists(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artists. Not returned if a callback is given.\n   */\n  getArtists: function getArtists(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists').withQueryParameters({\n      ids: artistIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Search for music entities of certain types.\n   * @param {string} query The search query.\n   * @param {string[]} types An array of item types to search across.\n   * Valid types are: 'album', 'artist', 'playlist', 'track', 'show', and 'episode'.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example search('Abba', ['track', 'playlist'], { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  search: function search(query, types, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/search/').withQueryParameters({\n      type: types.join(','),\n      q: query\n    }, options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Search for an album.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchAlbums('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchAlbums: function searchAlbums(query, options, callback) {\n    return this.search(query, ['album'], options, callback);\n  },\n  /**\n   * Search for an artist.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchArtists('David Bowie', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchArtists: function searchArtists(query, options, callback) {\n    return this.search(query, ['artist'], options, callback);\n  },\n  /**\n   * Search for a track.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchTracks('Mr. Brightside', { limit : 3, offset : 2 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchTracks: function searchTracks(query, options, callback) {\n    return this.search(query, ['track'], options, callback);\n  },\n  /**\n   * Search for playlists.\n   * @param {string} query The search query.\n   * @param {Object} options The possible options.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchPlaylists('workout', { limit : 1, offset : 0 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchPlaylists: function searchPlaylists(query, options, callback) {\n    return this.search(query, ['playlist'], options, callback);\n  },\n  /**\n   * Get an artist's albums.\n   * @param {string} artistId The artist's ID.\n   * @options {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistAlbums('0oSGxfWSnnOXhD2fKuz2Gy', { album_type : 'album', country : 'GB', limit : 2, offset : 5 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the albums\n   *          for the given artist. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  getArtistAlbums: function getArtistAlbums(artistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists/' + artistId + '/albums').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get the tracks of an album.\n   * @param albumId the album's ID.\n   * @options {Object} [options] The possible options, e.g. limit.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbumTracks('41MnTivkwTO3UUJ8DrqEJJ', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *                    tracks in the album. The result is paginated. If the promise is rejected.\n   *                    it contains an error object. Not returned if a callback is given.\n   */\n  getAlbumTracks: function getAlbumTracks(albumId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/albums/' + albumId + '/tracks').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get an artist's top tracks.\n   * @param {string} artistId The artist's ID.\n   * @param {string} country The country/territory where the tracks are most popular. (format: ISO 3166-1 alpha-2)\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistTopTracks('0oSGxfWSnnOXhD2fKuz2Gy', 'GB').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          artist's top tracks in the given country. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  getArtistTopTracks: function getArtistTopTracks(artistId, country, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists/' + artistId + '/top-tracks').withQueryParameters({\n      country: country\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get related artists.\n   * @param {string} artistId The artist's ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistRelatedArtists('0oSGxfWSnnOXhD2fKuz2Gy').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          related artists. If the promise is rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getArtistRelatedArtists: function getArtistRelatedArtists(artistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists/' + artistId + '/related-artists').build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get information about a user.\n   * @param userId The user ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getUser('thelinmichael').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the user. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getUser: function getUser(userId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/users/' + encodeURIComponent(userId)).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get information about the user that has signed in (the current user).\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getMe().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the user. The amount of information\n   *          depends on the permissions given by the user. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getMe: function getMe(callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me').build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get a user's playlists.\n   * @param {string} userId An optional id of the user. If you know the Spotify URI it is easy\n   * to find the id (e.g. spotify:user:<here_is_the_id>). If not provided, the id of the user that granted\n   * the permissions will be used.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getUserPlaylists('thelinmichael').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of playlists. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getUserPlaylists: function getUserPlaylists(userId, options, callback) {\n    var path;\n    if (typeof userId === 'string') {\n      path = '/v1/users/' + encodeURIComponent(userId) + '/playlists';\n    } else if (typeof userId === 'object') {\n      callback = options;\n      options = userId;\n      path = '/v1/me/playlists';\n    } /* undefined */else {\n      path = '/v1/me/playlists';\n    }\n    return WebApiRequest.builder(this.getAccessToken()).withPath(path).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get a playlist.\n   * @param {string} playlistId The playlist's ID.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getPlaylist('3EsfV6XzCHU8SPNdbnFogK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          the playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getPlaylist: function getPlaylist(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get tracks in a playlist.\n   * @param {string} playlistId The playlist's ID.\n   * @param {Object} [options] Optional options, such as fields.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getPlaylistTracks('3ktAYNcRHpazJ9qecm3ptn').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object that containing\n   * the tracks in the playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getPlaylistTracks: function getPlaylistTracks(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Create a playlist.\n   * @param {string} [name] The name of the playlist.\n   * @param {Object} [options] The possible options, being description, collaborative and public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example createPlaylist('My playlist', {''description': 'My description', 'collaborative' : false, 'public': true}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing information about the\n   *          created playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  createPlaylist: function createPlaylist(name, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/playlists').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      name: name\n    }, options).build().execute(HttpManager.post, callback);\n  },\n  /**\n   * Follow a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object} [options] The possible options, currently only public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  followPlaylist: function followPlaylist(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/followers').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(options).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Unfollow a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  unfollowPlaylist: function unfollowPlaylist(playlistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/followers').build().execute(HttpManager.del, callback);\n  },\n  /**\n   * Change playlist details.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object} [options] The possible options, e.g. name, public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example changePlaylistDetails('3EsfV6XzCHU8SPNdbnFogK', {name: 'New name', public: true}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  changePlaylistDetails: function changePlaylistDetails(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId).withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(options).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Replace the image used to represent a specific playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {string} base64URI Base64 encoded JPEG image data, maximum payload size is 256 KB\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example uploadCustomPlaylistCoverImage('3EsfV6XzCHU8SPNdbnFogK', 'longbase64uri').then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  uploadCustomPlaylistCoverImage: function uploadCustomPlaylistCoverImage(playlistId, base64URI, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/images').withHeaders({\n      'Content-Type': 'image/jpeg'\n    }).withBodyParameters(base64URI).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Add tracks to a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {string[]} tracks URIs of the tracks to add to the playlist.\n   * @param {Object} [options] Options, position being the only one.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example addTracksToPlaylist('3EsfV6XzCHU8SPNdbnFogK',\n              '[\"spotify:track:4iV5W9uYEdYUVa79Axb7Rh\", \"spotify:track:1301WleyT98MSxVHPZCA6M\"]').then(...)\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  addTracksToPlaylist: function addTracksToPlaylist(playlistId, tracks, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withQueryParameters(options).withBodyParameters({\n      uris: tracks\n    }).build().execute(HttpManager.post, callback);\n  },\n  /**\n   * Remove tracks from a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object[]} tracks An array of objects containing a property called uri with the track URI (String), and\n   * an optional property called positions (int[]), e.g. { uri : \"spotify:track:491rM2JN8KvmV6p0oDDuJT\", positions : [0, 15] }\n   * @param {Object} options Options, snapshot_id being the only one.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  removeTracksFromPlaylist: function removeTracksFromPlaylist(playlistId, tracks, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      tracks: tracks\n    }, options).build().execute(HttpManager.del, callback);\n  },\n  /**\n   * Remove tracks from a playlist by position instead of specifying the tracks' URIs.\n   * @param {string} playlistId The playlist's ID\n   * @param {int[]} positions The positions of the tracks in the playlist that should be removed\n   * @param {string} snapshot_id The snapshot ID, or version, of the playlist. Required\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  removeTracksFromPlaylistByPosition: function removeTracksFromPlaylistByPosition(playlistId, positions, snapshotId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      positions: positions,\n      snapshot_id: snapshotId\n    }).build().execute(HttpManager.del, callback);\n  },\n  /**\n   * Replace tracks in a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object[]} uris An array of track URIs (strings)\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  replaceTracksInPlaylist: function replaceTracksInPlaylist(playlistId, uris, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      uris: uris\n    }).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Reorder tracks in a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {int} rangeStart The position of the first track to be reordered.\n   * @param {int} insertBefore The position where the tracks should be inserted.\n   * @param {Object} options Optional parameters, i.e. range_length and snapshot_id.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  reorderTracksInPlaylist: function reorderTracksInPlaylist(playlistId, rangeStart, insertBefore, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      range_start: rangeStart,\n      insert_before: insertBefore\n    }, options).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Get audio features for a single track identified by its unique Spotify ID.\n   * @param {string} trackId The track ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioFeaturesForTrack('38P3Q4QcdjQALGF2Z92BmR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio features. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioFeaturesForTrack: function getAudioFeaturesForTrack(trackId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/audio-features/' + trackId).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get audio analysis for a single track identified by its unique Spotify ID.\n   * @param {string} trackId The track ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioAnalysisForTrack('38P3Q4QcdjQALGF2Z92BmR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio analysis. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioAnalysisForTrack: function getAudioAnalysisForTrack(trackId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/audio-analysis/' + trackId).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get audio features for multiple tracks identified by their unique Spotify ID.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioFeaturesForTracks(['38P3Q4QcdjQALGF2Z92BmR', '2HO2bnoMrpnZUbUqiilLHi']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio features for the tracks. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioFeaturesForTracks: function getAudioFeaturesForTracks(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/audio-features').withQueryParameters({\n      ids: trackIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Create a playlist-style listening experience based on seed artists, tracks and genres.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getRecommendations({ min_energy: 0.4, seed_artists: ['6mfK6Q2tzLMEchAr0e9Uzu', '4DYFVNKZ1uixa6SQTvzQwJ'], min_popularity: 50 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of tracks and a list of seeds. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getRecommendations: function getRecommendations(options, callback) {\n    var _opts = {};\n    var optionsOfTypeArray = ['seed_artists', 'seed_genres', 'seed_tracks'];\n    for (var option in options) {\n      if (options.hasOwnProperty(option)) {\n        if (optionsOfTypeArray.indexOf(option) !== -1 && Object.prototype.toString.call(options[option]) === '[object Array]') {\n          _opts[option] = options[option].join(',');\n        } else {\n          _opts[option] = options[option];\n        }\n      }\n    }\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/recommendations').withQueryParameters(_opts).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Retrieve a list of available genres seed parameter values for recommendations.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAvailableGenreSeeds().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of available genres to be used as seeds for recommendations.\n   *          If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAvailableGenreSeeds: function getAvailableGenreSeeds(callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/recommendations/available-genre-seeds').build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Retrieve the tracks that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist track objects. Not returned if a callback is given.\n   */\n  getMySavedTracks: function getMySavedTracks(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/tracks').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Check if one or more tracks is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the track ID in the request.\n   * The boolean value of true indicates that the track is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedTracks: function containsMySavedTracks(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/tracks/contains').withQueryParameters({\n      ids: trackIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Remove a track from the authenticated user's Your Music library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedTracks: function removeFromMySavedTracks(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      ids: trackIds\n    }).build().execute(HttpManager.del, callback);\n  },\n  /**\n   * Add a track from the authenticated user's Your Music library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedTracks: function addToMySavedTracks(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      ids: trackIds\n    }).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Remove an album from the authenticated user's Your Music library.\n   * @param {string[]} albumIds The album IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedAlbums: function removeFromMySavedAlbums(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/albums').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(albumIds).build().execute(HttpManager.del, callback);\n  },\n  /**\n   * Add an album from the authenticated user's Your Music library.\n   * @param {string[]} albumIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedAlbums: function addToMySavedAlbums(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/albums').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(albumIds).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Retrieve the albums that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist album objects. Not returned if a callback is given.\n   */\n  getMySavedAlbums: function getMySavedAlbums(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/albums').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Check if one or more albums is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} albumIds The album IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the album ID in the request.\n   * The boolean value of true indicates that the album is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedAlbums: function containsMySavedAlbums(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/albums/contains').withQueryParameters({\n      ids: albumIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get the current user's top artists based on calculated affinity.\n   * @param {Object} [options] Options, being time_range, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of artists,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyTopArtists: function getMyTopArtists(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/top/artists').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get the current user's top tracks based on calculated affinity.\n   * @param {Object} [options] Options, being time_range, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyTopTracks: function getMyTopTracks(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/top/tracks').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get the Current User's Recently Played Tracks\n   * @param {Object} [options] Options, being type, after, limit, before.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of play history objects,\n   *          otherwise an error. Not returned if a callback is given. Note that the response will be empty\n   *          in case the user has enabled private session.\n   */\n  getMyRecentlyPlayedTracks: function getMyRecentlyPlayedTracks(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/recently-played').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Add track or episode to device queue\n   * @param {string} [uri] uri of the track or episode to add\n   * @param {Object} [options] Options, being device_id.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  addToQueue: function addToQueue(uri, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/queue').withQueryParameters({\n      uri: uri\n    }, options).build().execute(HttpManager.post, callback);\n  },\n  /** \n   * Get the Current User's Available Devices\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of device objects,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyDevices: function getMyDevices(callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/devices').build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get the Current User's Currently Playing Track.\n   * @param {Object} [options] Options, being market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyCurrentPlayingTrack: function getMyCurrentPlayingTrack(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/currently-playing').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get Information About The User's Current Playback State\n   * @param {Object} [options] Options, being market and additional_types.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyCurrentPlaybackState: function getMyCurrentPlaybackState(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Transfer a User's Playback\n   * @param {string[]} [deviceIds] An _array_ containing a device ID on which playback should be started/transferred. \n   * (NOTE: The API is currently only supporting a single device ID.)\n   * @param {Object} [options] Options, the only one being 'play'.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  transferMyPlayback: function transferMyPlayback(deviceIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      device_ids: deviceIds\n    }, options).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Starts o Resumes the Current User's Playback\n   * @param {Object} [options] Options, being device_id, context_uri, offset, uris, position_ms.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example play({context_uri: 'spotify:album:5ht7ItJgpBH7W6vJ5BqpPr'}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  play: function play(options, callback) {\n    /*jshint camelcase: false */\n    var _options = options || {};\n    var queryParams = _options.device_id ? {\n      device_id: _options.device_id\n    } : null;\n    var postData = {};\n    ['context_uri', 'uris', 'offset', 'position_ms'].forEach(function (field) {\n      if (field in _options) {\n        postData[field] = _options[field];\n      }\n    });\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/play').withQueryParameters(queryParams).withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(postData).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Pauses the Current User's Playback\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example pause().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  pause: function pause(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/pause')\n    /*jshint camelcase: false */.withQueryParameters(options && options.device_id ? {\n      device_id: options.device_id\n    } : null).withHeaders({\n      'Content-Type': 'application/json'\n    }).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Skip the Current User's Playback To Previous Track\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example skipToPrevious().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  skipToPrevious: function skipToPrevious(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/previous').withQueryParameters(options && options.device_id ? {\n      device_id: options.device_id\n    } : null).build().execute(HttpManager.post, callback);\n  },\n  /**\n   * Skip the Current User's Playback To Next Track\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example skipToNext().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  skipToNext: function skipToNext(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/next').withQueryParameters(options && options.device_id ? {\n      device_id: options.device_id\n    } : null).build().execute(HttpManager.post, callback);\n  },\n  /**\n   * Seeks to the given position in the user’s currently playing track.\n   *\n   * @param {number} positionMs The position in milliseconds to seek to. Must be a positive number.\n   * @param {Object} options Options, being device_id. If left empty will target the user's currently active device.\n   * @param {function(Object,Object)} callback An optional callback that receives 2 parameters. The first\n   * one is the error object (null if no error), and the second is the value if the request succeeded.\n   * @return {Object} Null if a callback is provided, a `Promise` object otherwise\n   */\n  seek: function seek(positionMs, options, callback) {\n    var params = {\n      /* jshint camelcase: false */\n      position_ms: positionMs\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/seek').withQueryParameters(params).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Set Repeat Mode On The Current User's Playback\n   * @param {string} [state] State (track, context, or off)\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example setRepeat('context', {}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  setRepeat: function setRepeat(state, options, callback) {\n    var params = {\n      state: state\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/repeat').withQueryParameters(params).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Set Shuffle Mode On The Current User's Playback\n   * @param {boolean} [state] State \n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example setShuffle({state: 'false'}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  setShuffle: function setShuffle(state, options, callback) {\n    var params = {\n      state: state\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/shuffle').withQueryParameters(params).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Set the volume for the user’s current playback device.\n   * @param {number} volumePercent The volume to set. Must be a value from 0 to 100.\n   * @param {Object} options Options, being device_id. If left empty will target the user's currently active device.\n   * @param {function(Object,Object)} callback An optional callback that receives 2 parameters. The first\n   * one is the error object (null if no error), and the second is the value if the request succeeded.\n   * @return {Object} Null if a callback is provided, a `Promise` object otherwise\n   */\n  setVolume: function setVolume(volumePercent, options, callback) {\n    var params = {\n      /* jshint camelcase: false */\n      volume_percent: volumePercent\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/volume').withQueryParameters(params).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Add the current user as a follower of one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to be followed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example followUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  followUsers: function followUsers(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      ids: userIds.join(','),\n      type: 'user'\n    }).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Add the current user as a follower of one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to be followed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example followArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  followArtists: function followArtists(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      ids: artistIds.join(','),\n      type: 'artist'\n    }).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Remove the current user as a follower of one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to be unfollowed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example unfollowUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  unfollowUsers: function unfollowUsers(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      ids: userIds.join(','),\n      type: 'user'\n    }).build().execute(HttpManager.del, callback);\n  },\n  /**\n   * Remove the current user as a follower of one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to be unfollowed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example unfollowArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  unfollowArtists: function unfollowArtists(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      ids: artistIds.join(','),\n      type: 'artist'\n    }).build().execute(HttpManager.del, callback);\n  },\n  /**\n   * Check to see if the current user is following one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to check if are followed by the current user.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example isFollowingUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   *          of the returned array's elements correspond to the users IDs in the request.\n   *          The boolean value of true indicates that the user is following that user, otherwise is not.\n   *          Not returned if a callback is given.\n   */\n  isFollowingUsers: function isFollowingUsers(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following/contains').withQueryParameters({\n      ids: userIds.join(','),\n      type: 'user'\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get the current user's followed artists.\n   * @param {Object} [options] Options, being after and limit.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * album objects. Not returned if a callback is given.\n   */\n  getFollowedArtists: function getFollowedArtists(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      type: 'artist'\n    }, options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Check if users are following a playlist.\n   * @param {string} userId The playlist's owner's user ID\n   * @param {string} playlistId The playlist's ID\n   * @param {String[]} User IDs of the following users\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an array of booleans. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  areFollowingPlaylist: function areFollowingPlaylist(userId, playlistId, followerIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/users/' + encodeURIComponent(userId) + '/playlists/' + playlistId + '/followers/contains').withQueryParameters({\n      ids: followerIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Check to see if the current user is following one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to check if are followed by the current user.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example isFollowingArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   *          of the returned array's elements correspond to the artists IDs in the request.\n   *          The boolean value of true indicates that the user is following that artist, otherwise is not.\n   *          Not returned if a callback is given.\n   */\n  isFollowingArtists: function isFollowingArtists(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following/contains').withQueryParameters({\n      ids: artistIds.join(','),\n      type: 'artist'\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Retrieve new releases\n   * @param {Object} [options] Options, being country, limit and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * album objects. Not returned if a callback is given.\n   */\n  getNewReleases: function getNewReleases(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/new-releases').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Retrieve featured playlists\n   * @param {Object} [options] Options, being country, locale, timestamp, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * featured playlists. Not returned if a callback is given.\n   */\n  getFeaturedPlaylists: function getFeaturedPlaylists(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/featured-playlists').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Retrieve a list of categories used to tag items in Spotify (e.g. in the 'Browse' tab)\n   * @param {Object} [options] Options, being country, locale, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object of categories.\n   * Not returned if a callback is given.\n   */\n  getCategories: function getCategories(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/categories').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Retrieve a category.\n   * @param {string} categoryId The id of the category to retrieve.\n   * @param {Object} [options] Options, being country, locale.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a category object.\n   * Not returned if a callback is given.\n   */\n  getCategory: function getCategory(categoryId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/categories/' + categoryId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Retrieve playlists for a category.\n   * @param {string} categoryId The id of the category to retrieve playlists for.\n   * @param {Object} [options] Options, being country, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to a paging object containing simple playlists.\n   * Not returned if a callback is given.\n   */\n  getPlaylistsForCategory: function getPlaylistsForCategory(categoryId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/categories/' + categoryId + '/playlists').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get a show.\n   * @param {string} showId The show's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShow('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the show. Not returned if a callback is given.\n   */\n  getShow: function getShow(showId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/shows/' + showId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Look up several shows.\n   * @param {string[]} showIds The IDs of the shows.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShows(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the shows. Not returned if a callback is given.\n   */\n  getShows: function getShows(showIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/shows').withQueryParameters({\n      ids: showIds.join(',')\n    }, options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Check if one or more shows is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the show ID in the request.\n   * The boolean value of true indicates that the show is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedShows: function containsMySavedShows(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/shows/contains').withQueryParameters({\n      ids: showIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Remove an show from the authenticated user's Your Music library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedShows: function removeFromMySavedShows(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/shows').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(showIds).build().execute(HttpManager.del, callback);\n  },\n  /**\n   * Add a show from the authenticated user's Your Music library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedShows: function addToMySavedShows(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/shows').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(showIds).build().execute(HttpManager.put, callback);\n  },\n  /**\n   * Retrieve the shows that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist show objects. Not returned if a callback is given.\n   */\n  getMySavedShows: function getMySavedShows(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/shows').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Get the episodes of an show.\n   * @param showId the show's ID.\n   * @options {Object} [options] The possible options, being limit, offset, and market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShowEpisodes('41MnTivkwTO3UUJ8DrqEJJ', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *                    episodes in the album. The result is paginated. If the promise is rejected.\n   *                    it contains an error object. Not returned if a callback is given.\n   */\n  getShowEpisodes: function getShowEpisodes(showId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/shows/' + showId + '/episodes').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Search for a show.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchShows('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchShows: function searchShows(query, options, callback) {\n    return this.search(query, ['show'], options, callback);\n  },\n  /**\n   * Search for an episode.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchEpisodes('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchEpisodes: function searchEpisodes(query, options, callback) {\n    return this.search(query, ['episode'], options, callback);\n  },\n  /**\n    * Look up an episode.\n    * @param {string} episodeId The episode's ID.\n    * @param {Object} [options] The possible options, currently only market.\n    * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n    * @example getEpisode('3Qm86XLflmIXVm1wcwkgDK').then(...)\n    * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n    *          about the episode. Not returned if a callback is given.\n    */\n  getEpisode: function getEpisode(episodeId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/episodes/' + episodeId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n  /**\n   * Look up several episodes.\n   * @param {string[]} episodeIds The IDs of the episodes.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getEpisodes(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the episodes. Not returned if a callback is given.\n   */\n  getEpisodes: function getEpisodes(episodeIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/episodes').withQueryParameters({\n      ids: episodeIds.join(',')\n    }, options).build().execute(HttpManager.get, callback);\n  }\n};\nSpotifyWebApi._addMethods = function (methods) {\n  for (var i in methods) {\n    if (methods.hasOwnProperty(i)) {\n      this.prototype[i] = methods[i];\n    }\n  }\n};\nmodule.exports = SpotifyWebApi;","map":null,"metadata":{},"sourceType":"script"}